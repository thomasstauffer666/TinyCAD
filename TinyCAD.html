<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TinyCAD</title>
    <style>
        body {
            margin: 0;
        }
        canvas {
            display: block;
        }
        #menu {
            position: relative;
            top: 10px;
            left: 10px;
            background-color: #eee;
            display: inline-block;
            padding: 5px;
        }
        button {
            height: 30px;
        }
    </style>
</head>
<body>
    <div id="menu">
        <button data-function="addSphere">Add Sphere</button>
        <button data-function="addCube">Add Cube</button>
        <button data-function="addCone">Add Cone</button>
        <button data-function="addTorus">Add Torus</button>
        <button data-function="addCylinder">Add Cylinder</button>
        <button data-function="addHexagon">Add Hexagon</button>
        <button data-function="addMetaballs">Add Metaballs</button>
        <button data-function="addCubes">Add Cubes</button>
        <button data-function="addCSG">Add CSG</button>
        <button data-function="moveX">X+1</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/",
            "three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.7.3/build/index.module.js",
            "three-bvh-csg": "https://cdn.jsdelivr.net/npm/three-bvh-csg@0.0.16/build/index.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { MarchingCubes } from 'three/addons/objects/MarchingCubes.js';
        import { Brush, Evaluator, SUBTRACTION } from 'three-bvh-csg';

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.shadowMap.enabled = true;
        //renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0xffffff);

        const scene = new THREE.Scene();

        const raycaster = new THREE.Raycaster();

        document.body.appendChild(renderer.domElement);

        const objects = [];
        let selectedObject = null;

        // Lights

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(10.0, 10.0, 10.0);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.set(2048, 2048);
        scene.add(directionalLight);

        // Ground

        const ground = new THREE.Mesh(new THREE.PlaneGeometry(10.0, 10.0), new THREE.ShadowMaterial({opacity:0.15}));
        ground.rotation.x = -Math.PI/2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Grid

        const gridSize = 4;
        const gridDivisions = 40;
        const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x333333, 0xcccccc);
        scene.add(gridHelper);

        // X/Y/Z-Axis

        function createLine(color, start, end) {
            const material = new THREE.LineBasicMaterial({
                color: color,
                //depthTest: false,
            });
            const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
            const line = new THREE.Line(geometry, material);
            return line;
        }

        const axisLength = 1.0;

        const xAxis = createLine(0xff0000, new THREE.Vector3(0, 0, 0), new THREE.Vector3(axisLength, 0, 0));
        scene.add(xAxis);

        const yAxis = createLine(0x00ff00, new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, axisLength, 0));
        scene.add(yAxis);

        const zAxis = createLine(0x0000ff, new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, axisLength));
        scene.add(zAxis);

        function createRandomMaterial() {
            const material = new THREE.MeshStandardMaterial({
                color: Math.random() * 0xffffff,
                metalness: 0.3,
                roughness: 0.4,
                side: THREE.DoubleSide,
            });
            return material;
        }

        function addMesh(mesh) {
            mesh.castShadow = true;
            //mesh.receiveShadow = true;
            scene.add(mesh);
            objects.push(mesh);
        }

        function addSphere() {
            const geometry = new THREE.SphereGeometry(1, 32, 32);
            const material = createRandomMaterial();
            const mesh = new THREE.Mesh(geometry, material);
            mesh.name = 'Sphere';
            addMesh(mesh);
        }

        function addCube() {
            const geometry = new THREE.BoxGeometry(1.0, 1.0, 1.0);
            const material = createRandomMaterial();
            const mesh = new THREE.Mesh(geometry, material);
            mesh.name = 'Cube';
            addMesh(mesh);
        }

        function addCone() {
            const geometry = new THREE.ConeGeometry(0.5, 1, 32);
            const material = createRandomMaterial();
            const mesh = new THREE.Mesh(geometry, material);
            mesh.name = 'Cone';
            addMesh(mesh);
        }

        function addTorus() {
            const geometry = new THREE.TorusGeometry(1, 0.4, 16, 100);
            const material = createRandomMaterial();
            const mesh = new THREE.Mesh(geometry, material);
            mesh.name = 'Torus';
            addMesh(mesh);
        }

        function addCylinder() {
            const geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
            const material = createRandomMaterial();
            const mesh = new THREE.Mesh(geometry, material);
            mesh.name = 'Cylinder';
            addMesh(mesh);
        }

        function moveX() {
            if (selectedObject != null) {
                selectedObject.position.x += 1;
            }
        }

        function extrude2DTo3D(coordinates, height) {
            const material = createRandomMaterial();
            const shape = new THREE.Shape();
            shape.moveTo(coordinates[0].x, coordinates[0].y);
            for (let i = 1; i < coordinates.length; i++) {
                shape.lineTo(coordinates[i].x, coordinates[i].y);
            }
            shape.lineTo(coordinates[0].x, coordinates[0].y);
            const extrudeSettings = {
                depth: height,
                bevelEnabled: false
            };
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            const mesh = new THREE.Mesh(geometry, material);
            return mesh;
        }

        function addHexagon() {
            const radius = 0.5;
            const coords = [];
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2.0;
                coords.push({
                    x: Math.cos(angle) * radius,
                    y: Math.sin(angle) * radius,
                });
            }
            const mesh = extrude2DTo3D(coords, 1.0);
            addMesh(mesh);
        }

        function addMetaballs() {
            const material = createRandomMaterial();

            const resolution = 50;
            const marching = new MarchingCubes(resolution, material, true, true);
            marching.scale.set(1, 1, 1);

            const positions = [
                [0.5, 0.5, 0.5],
                [0.7, 0.5, 0.5],
                [0.3, 0.6, 0.5],
                [0.5, 0.4, 0.7],
                [0.5, 0.7, 0.3],
            ];

            const strength = 1.0;
            const subtract = 10;

            marching.reset();
            for (const p of positions) {
                marching.addBall(p[0], p[1], p[2], strength, subtract);
            }

            marching.update();
            addMesh(marching);
        }

        function addCubes() {
            const material = createRandomMaterial();

            const resolution = 50;
            const marching = new MarchingCubes(resolution, material, true, true);
            //marching.isolation = 1; // by default 80
            marching.scale.set(1, 1, 1);

            const size = resolution;
            const dim = 20;
            const offset = 15.0; // TODO why this offset?
            for (let x = 0; x < dim; x += 1) {
                for (let y = 0; y < dim; y += 1) {
                    for (let z = 0; z < dim; z += 1) {
                        marching.setCell(x + offset, y + offset, z + offset, 100);
                    }
                }
            }

            //marching.blur(0.2);

            marching.update();
            addMesh(marching);
        }

        function addCSG() {
            const geometry1 = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
            const material1 = createRandomMaterial();
            const mesh1 = new THREE.Mesh(geometry1, material1);
            mesh1.position.x = 0.2;
            //scene.add(mesh1);

            const geometry2 = new THREE.ConeGeometry(0.5, 1, 32);
            const material2 = createRandomMaterial();
            const mesh2 = new THREE.Mesh(geometry2, material2);
            //scene.add(mesh2);

            const brush1 = new Brush(geometry1, material1);
            const brush2 = new Brush(geometry2, material2);
            brush1.position.x = mesh1.position.x;
            brush1.updateMatrixWorld();
            brush2.updateMatrixWorld();
            const evaluator = new Evaluator();
            const resultBrush = evaluator.evaluate(brush1, brush2, SUBTRACTION);
            scene.add(resultBrush);
        }

        // Camera

        camera.position.set(1.0, 1.0, 1.0);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 1.0;
        controls.maxDistance = 100.0;

        // Resize

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize);
        onWindowResize();

        // UI

        const functions = {
            'addSphere': addSphere,
            'addCube': addCube,
            'addCone': addCone,
            'addTorus': addTorus,
            'addCylinder': addCylinder,
            'moveX': moveX,
            'addHexagon': addHexagon,
            'addMetaballs': addMetaballs,
            'addCubes': addCubes,
            'addCSG': addCSG,
        }

        document.querySelectorAll('button[data-function]').forEach(button => {
            button.addEventListener('click', function() {
                const functionName = this.getAttribute('data-function');
                console.log(functionName);
                functions[functionName]();
            });
        });

        function onMouseClick(event) {
            const mouse = new THREE.Vector2();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = (-event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(objects);

            if (intersects.length > 0) {
                selectedObject = intersects[0].object;
                //selectedObject.material.transparent = true;
                //selectedObject.material.opacity = 0.5;
                console.log('Selected object position:', selectedObject);
            }
        }

        window.addEventListener('click', onMouseClick);

        // Render

        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Required when damping is enabled
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>